<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>莱恩哈特的记事本</title>
    <link>https://mustang1988.github.io/</link>
    <description>Recent content on 莱恩哈特的记事本</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 28 Mar 2018 16:18:00 +0800</lastBuildDate>
    
        <atom:link href="https://mustang1988.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://mustang1988.github.io/about/</link>
      <pubDate>Wed, 28 Mar 2018 16:18:00 +0800</pubDate>
      
      <guid>https://mustang1988.github.io/about/</guid>
      
        <description></description>
      
    </item>
    
    <item>
      <title>Laravel模块化开发</title>
      <link>https://mustang1988.github.io/post/laravel%E6%A8%A1%E5%9D%97%E5%8C%96%E6%8B%86%E5%88%86/</link>
      <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mustang1988.github.io/post/laravel%E6%A8%A1%E5%9D%97%E5%8C%96%E6%8B%86%E5%88%86/</guid>
      
        <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Laravel项目的基本目录结构&lt;/p&gt;

&lt;p&gt;使用composer初始化一个laravel项目&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#composer create-project laravel/laravel MyLaravelProject
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化完成后观察目录结构基本如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;  .
  ├── app
  │    ├── Console
  │    │    └── Kernel.php
  │    ├── Exceptions
  │    │    └── Handler.php
  │    ├── Http
  │    │    ├── Controllers
  │    │    │    ├── Auth
  │    │    │    └── Controller.php
  │    │    ├── Kernel.php
  │    │    └── Middleware
  │    │        ├── EncryptCookies.php
  │    │        ├── RedirectIfAuthenticated.php
  │    │        ├── TrimStrings.php
  │    │        ├── TrustProxies.php
  │    │        └── VerifyCsrfToken.php
  │    ├── Providers
  │    │    ├── AppServiceProvider.php
  │    │    ├── AuthServiceProvider.php
  │    │    ├── BroadcastServiceProvider.php
  │    │    ├── EventServiceProvider.php
  │    │    └── RouteServiceProvider.php
  │    └── User.php
  ├── artisan
  ├── bootstrap
  │    ├── app.php
  │    └── cache
  │        ├── packages.php
  │        └── services.php
  ├── composer.json
  ├── composer.lock
  ├── config
  │    ├── app.php
  │    ├── auth.php
  │    ├── broadcasting.php
  │    ├── cache.php
  │    ├── database.php
  │    ├── filesystems.php
  │    ├── mail.php
  │    ├── queue.php
  │    ├── services.php
  │    ├── session.php
  │    └── view.php
  ├── database
  │    ├── factories
  │    ├── migrations
  │    └── seeds
  ├── package.json
  ├── phpunit.xml
  ├── public
  │    ├── css
  │    ├── favicon.ico
  │    ├── index.php
  │    ├── js
  │    ├── robots.txt
  │    └── web.config
  ├── readme.md
  ├── resources
  │    ├── assets
  │    ├── lang
  │    │    └── en
  │    │        ├── auth.php
  │    │        ├── pagination.php
  │    │        ├── passwords.php
  │    │        └── validation.php
  │    └── views
  │        └── welcome.blade.php
  ├── routes
  │    ├── api.php
  │    ├── channels.php
  │    ├── console.php
  │    └── web.php
  ├── server.php
  ├── storage
  ├── tests
  └── vendor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照框架的约定,通常在开发中&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据模型(models)会直接置于app目录下;&lt;/li&gt;
&lt;li&gt;控制器(controllers)会置于app/Http/Controllers目录下;&lt;/li&gt;
&lt;li&gt;路由配置(routers)会直接写在routes/api.php和web.php中&lt;/li&gt;
&lt;li&gt;页面视图(views)会置于resource/views目录下&lt;/li&gt;
&lt;li&gt;常量配置值(config)会置于config目录下
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实际开发中,一般都会按照框架的这些约定进行编码,这就导致了一些问题&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;随着项目功能的增加,数据模型层中的类越来越多,相互之间的关联越来越多,也就越来越多的会出现数据模型的关联查询,这就存在一种隐患,如果想迁移部分或所有的数据模型层,从现有数据库到其他数据库,这些关联查询,君有可能发生严重的异常;&lt;/li&gt;
&lt;li&gt;控制器类功能过于集中,无论是页面跳转的控制,还是数据接口的控制,都写在同一个类中,这导致控制器类的高度复杂,后期很难进行维护,这也不符合单一职责原则的要求;&lt;/li&gt;
&lt;li&gt;路由配置过于集中,项目越胖大,涉及的路由地址越多,router配置文件就越复杂,难以维护,许多格式类似的路由,很难进行查询&lt;/li&gt;
&lt;li&gt;页面视图文件集中在同一个目录下,命名冲突时有发生,只能通过不断的新建目录来分散文件&lt;/li&gt;
&lt;li&gt;常量配置基本同上面,过于集中,debug过程中,需要频繁的在很多文件的目录中进行切换,效率大打折扣&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为什么要拆分模块化开发&lt;/p&gt;

&lt;p&gt;正如前文分析的结果一样,按照框架约定的方式进行开发,会为后续的项目维护带来很大的不方便和维护成本的上升&lt;/p&gt;

&lt;p&gt;因此将同一功能拆分成模块,将相关模块的代码文件集中组合在一起,独立维护,同时又对外暴露接口,允许其他模块顺利访问是最简单有效的办法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模块化拆分方案&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;模块拆分准备&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建模块根目录,用于存放拆分后的模块&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在项目根目录,新建一个Modules目录;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为模块根目录设置根namespaces,laravel框架本身是完全遵循&lt;a href=&#34;http://www.php-fig.org/psr/psr-4/&#34;&gt;PSR-4&lt;/a&gt;标准进行类加载的,因此需要为模块目录设置根namespaces;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;autoload&amp;quot;: {
&amp;quot;classmap&amp;quot;: [
    &amp;quot;database&amp;quot;
],
&amp;quot;psr-4&amp;quot;: {
    &amp;quot;App\\&amp;quot;: &amp;quot;app/&amp;quot;,
    &amp;quot;Modules\\&amp;quot;:&amp;quot;Modules/&amp;quot;
}
},
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;laravel的&lt;a href=&#34;http://www.php-fig.org/psr/psr-4/&#34;&gt;PSR-4&lt;/a&gt;是通过composer-autoload实现的,因此在配置好模块的根namespaces后,一定需要重建composer的autoload,使得在运行过程中,模块中的类可以被正常的autoload&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;  #composer dump-autoload -o
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建各个功能模块的独立目录&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;完成根namespaces的定以后就可以在Modules目录下,按照业务需要新建各个功能模块的独立目录了&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置模块IOC注入&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在模块目录下新建Providers目录&lt;/li&gt;
&lt;li&gt;在Providers目录中新建模块服务注入类,继承自框架的Illuminate\Support\ServiceProvider类&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;  &amp;lt;?php

    namespace Modules\模块名称\Providers;

    use Illuminate\Support\ServiceProvider;

    class ModuleServiceProvider extends ServiceProvider
    {
        private $module_name = &#39;模块名称&#39;;

        public function register()
        {
            $this-&amp;gt;binds();
        }

        public function boot()
        {

        }

        private function binds()
        {

        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在框架核心配置文件config/app.php的providers数组中将新增的ModuleServiceProvider添加进去&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;  &amp;lt;?php
    ...
    &#39;providers&#39; =&amp;gt; [
      ...
      Modules\模块名称\Providers\ModuleServiceProvider::class,
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;拆分数据模型到模块&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在模块对应的目录下,新建Modules目录,用于放置当前模块相关的数据模型类;       * 注意,其中的数据模型类的namespaces一定要与先前设置的根namespace以及实际目录结构一致;
例如:
&amp;gt; 数据模型类的namespaces应该为
&amp;gt; Modules\模块名称\Models;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;拆分控制器到模块&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;仿照laravel的app目录下控制器的存放目录新建Http/Controllers目录用于放置控制器类&lt;/li&gt;
&lt;li&gt;同拆分数据模型类时类似,需要修改对应控制器类的namespaces
&amp;gt; 控制器目录namespaces应该为
&amp;gt; Modules\模块名称\Http\Controllers&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;拆分路由配置到模块&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在模块目录下新建Routes目录用于放置路由配置文件,可以现在该Routers目录下新建api.php和web.php两个路由配置文件,分别用来配置api接口和web页面跳转的路由;&lt;/li&gt;
&lt;li&gt;在模块的Provider目录新建路由配置注入类,继承自框架的Illuminate\Foundation\Support\Providers\RouteServiceProvider类
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;  &amp;lt;?php

    namespace Modules\模块名称\Providers;

    use Illuminate\Foundation\Support\Providers\RouteServiceProvider;
    use Route;

    class ModuleRouterServiceProvider extends RouteServiceProvider
    {
        protected $namespace = &#39;Modules\模块名称\Http\Controllers&#39;;

        public function boot()
        {
            parent::boot();
        }

        public function map()
        {
            $this-&amp;gt;mapApiRoutes();

            $this-&amp;gt;mapWebRoutes();
        }

        protected function mapWebRoutes()
        {
            Route::group([
                &#39;middleware&#39; =&amp;gt; &#39;web&#39;,
                &#39;namespace&#39; =&amp;gt; $this-&amp;gt;namespace,
            ], function ($router) {
                require base_path(&#39;Modules\模块名称/Routers/web.php&#39;);
            });
        }

        protected function mapApiRoutes()
        {
            Route::group([
                &#39;middleware&#39; =&amp;gt; &#39;api&#39;,
                &#39;namespace&#39; =&amp;gt; $this-&amp;gt;namespace,
                &#39;prefix&#39; =&amp;gt; &#39;api&#39;,
            ], function ($router) {
                require base_path(&#39;Modules\模块名称/Routers/api.php&#39;);
            });
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;编辑之前创建的ModuleServiceProvider,在register方法中,调用路由注入类的register方法,将路由配置,关联到模块注入配置&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;    &amp;lt;?php 
    ...
    public function register()
    {
        $this-&amp;gt;app-&amp;gt;register(ModulesRouterServiceProvider::class);
        $this-&amp;gt;binds();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;拆分视图文件到模块&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在模块目录下新建Views目录,用于取代resource/views目录,放置页面模板和blade模板引擎文件&lt;/li&gt;
&lt;li&gt;编辑之前创建的ModuleServiceProvider,boot方法中,将新增的视图目录,注入到框架的viewslocation中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;    &amp;lt;?php
    public function boot()
    {
        $view_location = sprintf(&#39;Modules/%s/Views&#39;, $this-&amp;gt;module_name);
        View::addLocation(base_path($view_location));
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;拆分常量配置到模块&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在模块目录下新建Configs目录,用于存放模块独立的常量配置,建议每个模块只使用一个单独的常量配置&lt;/li&gt;
&lt;li&gt;由于框架的加载机制,所有常量配置必须放置在configs目录下,才能正常被读取和使用,因此,拆分到模块Configs目录下的配置,在实际运行时还是要放置到configs目录下才能正常使用,为避免不必要的麻烦和自动化构建,框架本身提供了从指定的目录发布配置文件到configs目录的功能,在之前创建的ModuleServiceProvider中,在register方法中添加相关代码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;    &amp;lt;?php
    public function register()
    {
        $config_path = __DIR__ . &#39;/../Configs&#39;;
        if (function_exists(&#39;config_path&#39;)) {
            $publish_path = config_path(&#39;&#39;);
        } else {
            $publish_path = base_path(&#39;config/&#39;);
        }
        $this-&amp;gt;publishes([$config_path =&amp;gt; $publish_path], &#39;config&#39;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;拆分模块服务到模块&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在模块目录下新建Services目录,根据业务需要,在其中开发具体的业务服务的接口和实现类&lt;/li&gt;
&lt;li&gt;在模块的ModuleServiceProvider中的bind方法实现绑定实现类到接口实现DI和服务定位&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;拆分其他组件到模块&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;启发组件部分包括自定义异常,请求中间件,表单校验器等等,可以俺需要在模块目录下新建对应的Exceptions,Middlewares和Validators等目录&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模块化拆分后的基本目录结构&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;进行完上述的拆分过程后,完全模块化;模块代码独立目录管理的结构就完成了&lt;/li&gt;
&lt;li&gt;最终呈现的目录结构大致如下&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;  .
  ├── Modules
  │    ├── 模块名称
  │    │    ├── Configs
  │    │    │    └── xxx.php
  │    │    ├── Console
  │    │    ├── Exceptions
  │    │    │    └── xxxException.php
  │    │    ├── Http
  │    │    │    ├── Controllers
  │    │    │    └── Middlewares
  │    │    ├── Models
  │    │    │    └── xxxModel.php
  │    │    ├── Providers
  │    │    │    ├── xxxRouteServiceProvider.php
  │    │    │    └── xxxServiceProvider.php
  │    │    ├── Routers
  │    │    │    ├── api.php
  │    │    │    └── web.php
  │    │    ├── Services
  │    │    │    ├── Ifaces
  │    │    │    └── Impls
  │    │    ├── Validations
  │    │    │    └── xxxValidation.php
  │    │    └── Views
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模块化开发后部署上线的一些注意点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;由于拆分了配置文件到模块目录,因此项目上线时,必须先发布配置文件到config目录下&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;  # php artisan vender:publish --provider=&#39;Modules\模块名称\Providers\ModuleServiceProvider&#39; --force
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;这部分流程的执行是幂等的,可以加入到正常构建流程中,每次构建都执行,并不会有额外的影响&lt;/li&gt;
&lt;li&gt;在每次执行vender:publish后,由于框架本身存在的配置缓存问题,会出现publish了新的配置,但是并没有生效,此时就需要手动去清除默认缓存起来的配置值&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;  #php artisan compile-clear
  #php artisan config:clear 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>MongoDB 数据库数据迁移</title>
      <link>https://mustang1988.github.io/post/mongodb-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/</link>
      <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mustang1988.github.io/post/mongodb-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/</guid>
      
        <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;导出旧数据&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;mongodump -h 服务器ip  -d 需要导出的数据库 -o 导出文件所在目录&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;导出完成后会在指定目录生成对应数据库名称的目录,其中有.json 和 .bson格式的数据&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;拷贝导出的数据文件到新数据库所在服务器&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;导入旧数据&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;mongorestore -h 服务器ip &amp;ndash;port 端口 [-u 用户名 -p 密码] -d 数据库名称 [&amp;ndash;drop] 数据文件路径&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>使用Dockerfile构建自己的docker镜像</title>
      <link>https://mustang1988.github.io/post/%E4%BD%BF%E7%94%A8dockerfile%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84docker%E9%95%9C%E5%83%8F/</link>
      <pubDate>Wed, 12 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mustang1988.github.io/post/%E4%BD%BF%E7%94%A8dockerfile%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84docker%E9%95%9C%E5%83%8F/</guid>
      
        <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;为什么要自己构建docker镜像?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;docker镜像是啥&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。&lt;/p&gt;

&lt;p&gt;字面意思就是,docker镜像就是一个可以被docker daemon解析并运行的软件包,里面包含一个完成的操作系统和需要运行的应用程序.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Dockerfile是啥&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Docker can build images automatically by reading the instructions from a Dockerfile, a text file that contains all the commands, in order, needed to build a given image.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是官方文档上给出的描述,Dockerfile包含了一组指令,可以被docker用来自动的读取和执行后得到指定的docker镜像.&lt;/p&gt;

&lt;p&gt;Dockerfile是官方提供的一种拥有可读性的,可重复利的,可定制的构建docker镜像的方式.是构建docker镜像的方式之一.&lt;/p&gt;

&lt;p&gt;除了Dockerfile还有其他方式来构建docker镜像,但是不能满足下面会提及的一些需求,官方也不是很推荐,就不再介绍了.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;为啥要自己构建镜像?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;原因很简单,每个人/每家公司企业都有自己的技术方向和惯用的解决方案,使用通用镜像是无法适配多种多样特殊的要求的.很容易出现诸如性能瓶颈,业务瓶颈等等问题.&lt;/p&gt;

&lt;p&gt;为了实现足够高的匹配度,那么自己定制一个针对自己业务/技术进行充分优化和调整的运行环境是必须和必要的.&lt;strong&gt;私人订制&lt;/strong&gt;,这就是自己构建镜像的价值所在.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/engine/reference/builder/&#34;&gt;&lt;strong&gt;开始构建自己的docker镜像&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面将以生产环境所使用的&lt;a href=&#34;http://10.7.12.3:8080/repo/tag/dev%252Fphp/7.1.6-nginx-opcache&#34;&gt;&lt;strong&gt;php-fpm(v7.1.6)+nginx(v1.12)&lt;/strong&gt;&lt;/a&gt;的docker镜像的制作过程来讲解构建自己的docker镜像的过程.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;hello world&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;先来一段Dockerfile示例,大致认识下一个Dockerfile的构成:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    FROM        some image
    ENV         some env
    #           some comments
    RUN         some command
    COPY        some files
    EXPOSE      some ports
    WORKDIR     a dir
    VOLUME      a dir
    ENTRYPOINT [&amp;quot;some command&amp;quot;,&amp;quot;params&amp;quot;]
            
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;选择底料&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    FROM some image
            
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面示例的这一部分&lt;/p&gt;

&lt;p&gt;作用是为你的所要构建的镜像选择一个底包,通常这个底包都会是一个操作系统的官方镜像,比如:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;FROM centos:7.0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个底包的选择是很随意的,任何一个现成的docker镜像都能被作为你要构建镜像的底包,没有任何限制.&lt;/p&gt;

&lt;p&gt;那么一定会有人问,我如果想要自己构建一个操作系统的镜像要怎么玩?我需要一个没有操作系统的底包,去哪找??&lt;/p&gt;

&lt;p&gt;答案其实很简单,docker官方提供了最底层的,只包含文件系统的&lt;a href=&#34;https://docs.docker.com/glossary/?term=base%20image&#34;&gt;Base镜像&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;我所选择的底包是php官方构建的&lt;a href=&#34;https://hub.docker.com/_/php/&#34;&gt;php:7.1.6-fpm-alpine&lt;/a&gt;镜像.这个镜像基于alpine linux的3.4版本制作,特点是体积小,很小,非常小.操作系统本身的大小只有 &lt;strong&gt;不到5MB&lt;/strong&gt; (CentOS/Ubuntu的官方底包至少也要300~500MB),加上php官方构建后整体大小不到90MB,非常方便快速的部署.&lt;/p&gt;

&lt;p&gt;Dockerfile 示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    FROM php:7.1.6-fpm-alpine
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;加点调料&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这一步会对将要构建的环境进行基本的设置,为后续的操作做准备内容包括环境变量的设置,程序依赖的安装,用户/组的创建等等.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ENV 命令 // 设置环境变量&lt;/p&gt;

&lt;p&gt;RUN 命令 // 执行指定的系统命令&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Dockerfile示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ENV NGINX_VERSION 1.12.0
    RUN apk update \
        &amp;amp;&amp;amp; apk add --no-cache --virtual .phpdeps \
        $PHPIZE_DEPS \
        openssl-dev \
        pcre-dev \
        libpng-dev \
        freetype-dev \
        libjpeg-turbo-dev \
        libpng-dev \
        libxml2-dev \
        tzdata
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;来点硬菜&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这一步将开始安装所需要的核心应用,nginx&lt;/p&gt;

&lt;p&gt;编写方式就像你已经ssh登录进这台主机一样,编译安装等等都可以在这部分进行操作.&lt;/p&gt;

&lt;p&gt;Dockerfile示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    RUN GPG_KEYS=B0F4253373F8F6F510D42178520A9993A1C052F8 \
    &amp;amp;&amp;amp; CONFIG=&amp;quot;\
        --prefix=/etc/nginx \
        --sbin-path=/usr/sbin/nginx \
        --modules-path=/usr/lib/nginx/modules \
        --conf-path=/etc/nginx/nginx.conf \
        --error-log-path=/var/log/nginx/error.log \
        --http-log-path=/var/log/nginx/access.log \
        --pid-path=/var/run/nginx.pid \
        --lock-path=/var/run/nginx.lock \
        --http-client-body-temp-path=/var/cache/nginx/client_temp \
        --http-proxy-temp-path=/var/cache/nginx/proxy_temp \
        --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp \
        --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp \
        --http-scgi-temp-path=/var/cache/nginx/scgi_temp \
        --user=nginx \
        --group=nginx \
        --with-http_ssl_module \
        --with-http_realip_module \
        --with-http_addition_module \
        --with-http_sub_module \
        --with-http_dav_module \
        --with-http_flv_module \
        --with-http_mp4_module \
        --with-http_gunzip_module \
        --with-http_gzip_static_module \
        --with-http_random_index_module \
        --with-http_secure_link_module \
        --with-http_stub_status_module \
        --with-http_auth_request_module \
        --with-http_xslt_module=dynamic \
        --with-http_image_filter_module=dynamic \
        --with-http_geoip_module=dynamic \
        --with-threads \
        --with-stream \
        --with-stream_ssl_module \
        --with-stream_ssl_preread_module \
        --with-stream_realip_module \
        --with-stream_geoip_module=dynamic \
        --with-http_slice_module \
        --with-mail \
        --with-mail_ssl_module \
        --with-compat \
        --with-file-aio \
        --with-http_v2_module \
        &amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;餐后甜点&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这一步主要目的是将一些来自外部的应用/系统的设置,植入镜像中&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;COPY 命令 // 从构建机复制指定的文件/目录到容器中&lt;/p&gt;

&lt;p&gt;ADD 命令  // 将指定的文件/目录/URL所对应的文件复制到容器中,和COPY的区别就是支持URL&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Dockerfile示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    COPY supervisord.conf /etc/supervisord.conf

    COPY start.sh /start.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;饭后活动&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这一步是为了以后使用这个构建出来的环境准备对外暴露的接入方式&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;VOLUME 命令 //  创建挂载点,创建的挂载点后,在启动容器时不再需要使用-v参数指定挂在&lt;/p&gt;

&lt;p&gt;EXPOSE 命令 // 用于显示声明容器内应用将会对外暴露的端口,启动容器时需要使用-p参数才会真正映射端口到宿主机&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Dockerfile示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    EXPOSE 9001 80 443 9000
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;收工&amp;amp;结束&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这一步是可选的,用来设置当前制作的镜像启动后的默认动作,在启动容器时可以通过CMD参数来覆盖这个设置的值,不覆盖则默认会执行.&lt;/p&gt;

&lt;p&gt;Dockerfile示例:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ENTRYPOINT 命令 // 设置默认启动行为,只允许有一个,如果写了多个,最后一个会生效,大部分情况下推荐使用ENTRYPOINT,而非CMD命令&lt;/p&gt;

&lt;p&gt;WORKDIR 命令 // 切换操作目录,类似于cd命令,在dockerfile中写cd命令是无效的,需要注意&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    ENTRYPOINT [&amp;quot;sh&amp;quot;,&amp;quot;/start.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;完整Dockerfile奉上&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mustang1988/docker-images/blob/master/php/7.1.6/with-nginx-tools/Dockerfile&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Tips&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;RUN优化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;dockerfile构建的镜像是分层的,每一层都会占据独立的空间,为了节约,请将能合并的RUN命令,尽可能的合并到一条中用 &amp;amp;&amp;amp; 连接.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;清理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;编译安装应用后切记把一些无用的仅编译时需要的组件删除掉,以节约镜像体积,当然还有编译安装时所用到的源码文件,总之就是能删掉的统统删掉,镜像体积能小多少小多少,这和造车轻量化是一样一样一样的.没有人会喜欢一个动不动就几个GB的镜像,那会让你发疯的.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;编写说明文档&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;编写相关的文档,描述镜像的适用范围,暴露的端口,挂载点等等等,为日后的维护提供支持.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;持续构建&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Dockerfile编写完成了,要如何把它构建成镜像呢:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;docker build -t tag名称 Dockerfile所在目录&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;镜像构建的时间是和Dockerfile文件的复杂程度成正比的,还和其他很多因素有关,比如网速,设备性能等等.&lt;/p&gt;

&lt;p&gt;但是每次修改镜像都要手动去执行命令构建是很麻烦的过程,能不能让他监听Dockerfile的改动自动进行呢?答案是可以的.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;docker官方的DockerHub平台就提供了自动构建的功能.下面会简单介绍如何在dockerhub上实现自动构建镜像.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;打开&lt;a href=&#34;https://hub.docker.com/&#34;&gt;DockerHub&lt;/a&gt;页面,&lt;strong&gt;需要翻墙&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;点击登录,推荐使用GitHub帐号登录&lt;/li&gt;

&lt;li&gt;&lt;p&gt;点击右上角的Create-&amp;gt;Create Automated Build&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-13%2000.15.06.png?imageView/2/w/500&#34; alt=&#34;此处应有图&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选择使用GitHub构建&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然后选择你在GitHub创建的构建用的代码库,没有的话可以现去创建一个,公仓私仓都可以(私仓是收费唉,我不是土豪,用不起)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然后填写一些相关的描述文字,点击创建即可,然后就会进入Build Setting页面&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-13%2000.18.06.png?imageView/2/w/500&#34; alt=&#34;此处应有图&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;记得勾选左上角的&amp;rdquo;When active, builds will happen automatically on pushes.&amp;ldquo;,然后选择代码库指定分支,指定目录和对应的镜像Tag,点击保存即可&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;完成上述设置后,当你向指定分支触发push代码的操作后,就会自动读取该分支,该目录下的Dockerfile自动构建镜像了,需要注意构建文件必须使用固定的文件名Dockerfile,大小写敏感.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;由于DockerHub需要翻墙,对吾等天朝民工太不友好,阿里,网易均提供了类似的仓库和构建服务.经过构建速度/镜像拉取速度等方面的比对,发现阿里提供的构建服务完爆网易蜂巢,还是很推荐的.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;打开&lt;a href=&#34;https://dev.aliyun.com/search.html?spm=5176.1972344.0.1.8Ee7SL&#34;&gt;阿里开发者平台&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;点击右上角的管理中心,并登录&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建一个镜像仓库&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-13%2000.46.06.png?imageView/2/w/500&#34; alt=&#34;此处应有图&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置代码源位GitHub,当然也支持其他私有的git仓库&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然后同DockerHub类似的设置分支,目录,标签名等参数(阿里支持非Dockerfile命名的构建文件,这个很贴心,给个赞)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-13%2000.26.25.png?imageView/2/w/500&#34; alt=&#34;此处应有图&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;推送你的Dockerfile到仓库吧&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;记得勾选设置中的&amp;rdquo;代码变更时自动构建镜像&amp;rdquo;和&amp;rdquo;海外机器构建&amp;rdquo;,你会发现下载海外依赖包的速度真的是飞快,比DockerHub还要快一倍以上,赞~赞~赞~&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在仓库基本设置中可以看到自己构建镜像的公开地址,直接复制后面接上&amp;rdquo;:tag名称&amp;rdquo;就可以拉取了.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-13%2000.29.02.png?imageView/2/w/500&#34; alt=&#34;此处应有图&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用自动构建时,记得把你需要ADD或者COPY进镜像的文件和Dockerfile一起提交到版本库.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>Thrift生成PHP接口</title>
      <link>https://mustang1988.github.io/post/thrift%E7%94%9F%E6%88%90php%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Thu, 27 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mustang1988.github.io/post/thrift%E7%94%9F%E6%88%90php%E6%8E%A5%E5%8F%A3/</guid>
      
        <description>&lt;p&gt;本文所使用thrift版本(&lt;a href=&#34;https://thrift.apache.org/download&#34;&gt;0.10.0&lt;/a&gt;)&lt;/p&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;支持&lt;a href=&#34;http://www.php-fig.org/psr/psr-4/&#34;&gt;PSR4&lt;/a&gt;自动加载标准&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ thrift --out {OUTPUT_DIR} --gen php:psr4 {THRIFT_FILE}&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;{OUTPUT_DIR}为php接口文件的输出目录&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;{THRIFT_FILE}为需要生成接口的thrift协议文件&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;支持指定namespace&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ thrift --out {OUTPUT_DIR} --gen php:psr4,nsglobal={NAMESPACE} {THRIFT_FILE}&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果NAMESPACE有多层级,注意使用引号引起来&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>PHP 中的 Trait</title>
      <link>https://mustang1988.github.io/post/php-%E4%B8%AD%E7%9A%84trait/</link>
      <pubDate>Mon, 17 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mustang1988.github.io/post/php-%E4%B8%AD%E7%9A%84trait/</guid>
      
        <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Trait是神马&lt;/p&gt;

&lt;p&gt;Trait是PHP5.4.0中加入的语言特性,是一种代码复用机制,为了解决类的单继承导致的一些局限性问题.可以简单理解为一种多重继承的一种替代方案.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Trait和类的继承有何区别&lt;/p&gt;

&lt;p&gt;Trait和类相似, 但仅仅旨在用细粒度和一致的方式来组合功能, Trait无法实例化成具体的对象,如果将传统类的继承理解为纵向的代码复用与拓展,那么trait就提供了横向代码复用的能力.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Trait的具体使用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;什么时候可以使用trait?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;理论上凡是需要或将要使用继承的地方都可以考虑使用trait来实现,其次当有两个完全无关的类(无继承关系,各自有自己独立的父类),但是这两个类有需要编写相同的逻辑实现时,就可以考虑使用trait来拓展类的功能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Trait的使用方式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Trait官方示例:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-17%2015.29.26.png&#34; alt=&#34;官方示例&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Trait和类继承同时使用时的覆盖问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从基类继承的成员会被 trait 插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了 trait 的方法，而 trait 则覆盖了被继承的方法。&lt;/p&gt;

&lt;p&gt;优先级顺序:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;子类override的父类方法 &amp;gt; trait方法 &amp;gt; 子类继承自父类的方法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当前类的成员方法 &amp;gt; trait方法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;多个Trait同时使用&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;和implement接口类似,在use引入trait时,允许同时引入多个trait,并使用逗号隔开.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;trait冲突&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当一个类引入了多个trait,且这些trait中都定义了相同名称的方法,此时就会出现trait冲突,如果逻辑中没有编写对应的处理,则会抛出异常中断执行.
当发生trait冲突时,需要使用 insteadof 操作符来明确指定使用冲突方法中的哪一个。以上方式仅允许排除掉其它方法，as 操作符可以将其中一个冲突的方法以另一个名称来引入。&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-17%2015.32.12.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-17%2015.32.20.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;trait的组合&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;trait支持组合使用,也就是在一个trait中可以引入另一个或多个 trait来组合成一个新的trait,通过把逻辑实现的最小单元化,理论上可以用不同的trait排列组合,整合出无穷多的新trait,从而取代传统类的继承都不在话下.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;trait中的抽象成员&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;trait中也允许定义抽象成员方法,当有其他类引用该trait时必须对其中的抽象方法编写实现,类似于抽象类和接口的使用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;trait中可以定义静态方法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;trait中的属性定义&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;trait中可以定义属性,如果引入trait的类和trait中定义的属性存在冲突,则会抛出异常,但是,如果类中定义的属性和trait中定义的属性兼容(相同的访问修饰符和初始值)则类中的属性会覆盖trait中的,否则抛出异常.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;总结&lt;/p&gt;

&lt;p&gt;Trait特性可以说从根本上解决了单继承语言代码横向复用的大问题,利用trait的自由任意组合的机制,理论上都可以吧类的继承完全替代掉.但是trait使用时需要注意的问题点也比较多,尤其是成员方法的命名冲突,因为PHP是没有方法重载的,所以这个问题会变得尤其突出,所以在我们日常使用的时候需要特别小心.&lt;/p&gt;

&lt;p&gt;现如今主流的PHP框架中都或多或少的引入了trait特性来实现一些意想不到的功能,比如yii的ORM组件就大量的使用了trait来组合通用的数据库查询实现:&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>Git Commit 规范指南</title>
      <link>https://mustang1988.github.io/post/git-commit-%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/</link>
      <pubDate>Fri, 14 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mustang1988.github.io/post/git-commit-%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/</guid>
      
        <description>

&lt;h2 id=&#34;1-commit-message-有啥用&#34;&gt;1. Commit message 有啥用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;提供更多的历史信息，方便快速浏览&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以过滤某些commit(比如文档改动)，便于快速查找信息&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以直接从commit生成Change log,Change Log 是发布新版本时，用来说明与上一个版本差异的文档.例如:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clowuddn.com/6632199163166779416.png?imageView/2/w/350&#34; alt=&#34;example&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;其他优点:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可读性好，清晰，不必深入看代码即可了解当前commit的作用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为 Code Reviewing 做准备&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;方便跟踪工程历史&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;让其他的开发者在运行 git blame 的时候想跪谢&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提高项目的整体质量，提高个人工程素质&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-正确的-commit-message-的使用姿势&#34;&gt;2. 正确的 Commit message 的使用姿势&lt;/h2&gt;

&lt;p&gt;每次提交，Commit message 都包括三个部分：Header，Body 和 Footer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;type&amp;gt;(&amp;lt;scope&amp;gt;): &amp;lt;subject&amp;gt;
    &amp;lt;空行&amp;gt;
    &amp;lt;body&amp;gt;
    &amp;lt;空行&amp;gt;
    &amp;lt;footer&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-header&#34;&gt;1. Header&lt;/h3&gt;

&lt;p&gt;Header部分只有一行，包括三个字段：type(必需)、scope(可选)和subject(必需)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;type&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用于说明 commit 的类别，只允许使用下面7个标识&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;标识&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;feat&lt;/td&gt;
&lt;td&gt;新增功能(feature)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;fix&lt;/td&gt;
&lt;td&gt;修复bug&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;docs&lt;/td&gt;
&lt;td&gt;文档更新&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;style&lt;/td&gt;
&lt;td&gt;更新代码格式,不影响代码的原始逻辑和执行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;refactor&lt;/td&gt;
&lt;td&gt;重构(即不是新增功能，也不是修改bug的代码)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;test&lt;/td&gt;
&lt;td&gt;新增单元测试用例&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;chore&lt;/td&gt;
&lt;td&gt;构建过程或辅助工具的变动&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;perf&lt;/td&gt;
&lt;td&gt;提升优化性能&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;deps&lt;/td&gt;
&lt;td&gt;升级依赖&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;scope&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同
如果你的修改影响了不止一个scope，你可以使用*代替&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;subject&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;subject是 commit 目的的简短描述需要注意以下事项:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;注意点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不超过50个字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;以动词开头，使用第一人称现在时，比如change，而不是changed或changes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;第一个字母小写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;结尾不加句号（.）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-body&#34;&gt;2. Body&lt;/h3&gt;

&lt;p&gt;Body 部分是对本次 commit 的详细描述，可以分成多行,Body编写注意点:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;注意点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;每行不超过72个字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;段落之间用空行隔开&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;分段表述时,使用悬挂缩进&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用第一人称现在时，比如使用change而不是changed或changes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;应该说明代码变动的动机，以及与以前行为的对比&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;3-footer&#34;&gt;3. Footer&lt;/h3&gt;

&lt;p&gt;通常情况下的commit是不需要编写Footer部分的说明的,仅在以下情况发生时编写&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不兼容变动&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;关闭 Issue&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Revert&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header.Body部分的格式是固定的，必须写成This reverts commit &lt;hash&gt;.，其中的hash是被撤销 commit 的 SHA 标识符.如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面&lt;/p&gt;

&lt;h3 id=&#34;4-示例&#34;&gt;4.示例&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;初始化创建一个新的Git版本库&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;给初始化提交添加版本标签(0.0.1)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/init.png&#34; alt=&#34;init&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;提交一个新功能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git log 0.0.1 HEAD --grep feat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/feat.png&#34; alt=&#34;feat&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提交一个bug修正&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git log 0.0.1 HEAD --grep fix
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/fix.png&#34; alt=&#34;fix&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提交一次文档更新&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git log 0.0.1 HEAD --grep docs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/docs.png&#34; alt=&#34;docs&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提交一次代码格式修改&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  git log 0.0.1 HEAD --grep style
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/style.png&#34; alt=&#34;style&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;提交一次代码优化重构&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  git log 0.0.1 HEAD --grep refactor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/refactor.png&#34; alt=&#34;refactor&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;提交一个单元测试&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  git log 0.0.1 HEAD --grep test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/test.png&#34; alt=&#34;test&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;查看所有git提交记录
&lt;code&gt;
git log 0.0.1 HEAD --pretty=format:%s
&lt;/code&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-19%2015.54.18.png&#34; alt=&#34;log&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;a href=&#34;https://github.com/jonas/tig&#34;&gt;tig&lt;/a&gt;查看到的提交记录:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-19%2015.59.36.png&#34; alt=&#34;tig&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-生成changelog&#34;&gt;5.生成changelog&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装工具&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g conventional-changelog-cli
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置conventional-changelog&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  cd  项目目录
  npm init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改 package.json,添加:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  &amp;quot;scripts&amp;quot;: {
      &amp;quot;changelog&amp;quot;: &amp;quot;conventional-changelog -p angular -i CHANGELOG.md -s -r 0&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;执行命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm run changelog
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看版本库目录下生成的CHANGELOG.md文件,如下图所示:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/changelog.png?imageView/2/w/350&#34; alt=&#34;changelog&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;工具默认只会将feat和fix这两个type的commit信息抓取出来并生成到CHANGELOG.md文件中.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-sourcetree-配置默认commit-message-模板&#34;&gt;6.SourceTree 配置默认commit message 模板&lt;/h3&gt;

&lt;p&gt;SourceTree提供了自定义的提交模板配置功能.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在SourceTree中点击仓库菜单-&amp;gt;仓库设置-&amp;gt;提交模板
填入以下内容:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type(scope): subject  

body  

bodydetail  

foot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存设置,之后每次commit代码时,这个模板就会自动的填充到commit message中,然后我们只需要替换修改必要的部分就好了.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-参考文献&#34;&gt;3.参考文献:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.uyo6cb12dt6w&#34;&gt;AngularJS Git Commit Message Conventions&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000009048911&#34;&gt;git commit 规范指南&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html&#34;&gt;Commit message 和 Change log 编写指南&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/angular/angular.js/blob/master/CONTRIBUTING.md#toc10&#34;&gt;Contributing to AngularJS&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
  </channel>
</rss>