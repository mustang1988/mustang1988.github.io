<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>莱恩哈特的记事本</title>
    <link>https://mustang1988.github.io/</link>
    <description>Recent content on 莱恩哈特的记事本</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 28 Mar 2018 16:18:00 +0800</lastBuildDate>
    
        <atom:link href="https://mustang1988.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://mustang1988.github.io/about/</link>
      <pubDate>Wed, 28 Mar 2018 16:18:00 +0800</pubDate>
      
      <guid>https://mustang1988.github.io/about/</guid>
      
        <description></description>
      
    </item>
    
    <item>
      <title>使用Dockerfile构建自己的docker镜像</title>
      <link>https://mustang1988.github.io/post/%E4%BD%BF%E7%94%A8dockerfile%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84docker%E9%95%9C%E5%83%8F/</link>
      <pubDate>Wed, 12 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mustang1988.github.io/post/%E4%BD%BF%E7%94%A8dockerfile%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84docker%E9%95%9C%E5%83%8F/</guid>
      
        <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;为什么要自己构建docker镜像?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;docker镜像是啥&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。&lt;/p&gt;

&lt;p&gt;字面意思就是,docker镜像就是一个可以被docker daemon解析并运行的软件包,里面包含一个完成的操作系统和需要运行的应用程序.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Dockerfile是啥&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Docker can build images automatically by reading the instructions from a Dockerfile, a text file that contains all the commands, in order, needed to build a given image.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是官方文档上给出的描述,Dockerfile包含了一组指令,可以被docker用来自动的读取和执行后得到指定的docker镜像.&lt;/p&gt;

&lt;p&gt;Dockerfile是官方提供的一种拥有可读性的,可重复利的,可定制的构建docker镜像的方式.是构建docker镜像的方式之一.&lt;/p&gt;

&lt;p&gt;除了Dockerfile还有其他方式来构建docker镜像,但是不能满足下面会提及的一些需求,官方也不是很推荐,就不再介绍了.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;为啥要自己构建镜像?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;原因很简单,每个人/每家公司企业都有自己的技术方向和惯用的解决方案,使用通用镜像是无法适配多种多样特殊的要求的.很容易出现诸如性能瓶颈,业务瓶颈等等问题.&lt;/p&gt;

&lt;p&gt;为了实现足够高的匹配度,那么自己定制一个针对自己业务/技术进行充分优化和调整的运行环境是必须和必要的.&lt;strong&gt;私人订制&lt;/strong&gt;,这就是自己构建镜像的价值所在.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/engine/reference/builder/&#34;&gt;&lt;strong&gt;开始构建自己的docker镜像&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面将以生产环境所使用的&lt;a href=&#34;http://10.7.12.3:8080/repo/tag/dev%252Fphp/7.1.6-nginx-opcache&#34;&gt;&lt;strong&gt;php-fpm(v7.1.6)+nginx(v1.12)&lt;/strong&gt;&lt;/a&gt;的docker镜像的制作过程来讲解构建自己的docker镜像的过程.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;hello world&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;先来一段Dockerfile示例,大致认识下一个Dockerfile的构成:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    FROM        some image
    ENV         some env
    #           some comments
    RUN         some command
    COPY        some files
    EXPOSE      some ports
    WORKDIR     a dir
    VOLUME      a dir
    ENTRYPOINT [&amp;quot;some command&amp;quot;,&amp;quot;params&amp;quot;]
            
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;选择底料&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    FROM some image
            
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面示例的这一部分&lt;/p&gt;

&lt;p&gt;作用是为你的所要构建的镜像选择一个底包,通常这个底包都会是一个操作系统的官方镜像,比如:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;FROM centos:7.0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个底包的选择是很随意的,任何一个现成的docker镜像都能被作为你要构建镜像的底包,没有任何限制.&lt;/p&gt;

&lt;p&gt;那么一定会有人问,我如果想要自己构建一个操作系统的镜像要怎么玩?我需要一个没有操作系统的底包,去哪找??&lt;/p&gt;

&lt;p&gt;答案其实很简单,docker官方提供了最底层的,只包含文件系统的&lt;a href=&#34;https://docs.docker.com/glossary/?term=base%20image&#34;&gt;Base镜像&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;我所选择的底包是php官方构建的&lt;a href=&#34;https://hub.docker.com/_/php/&#34;&gt;php:7.1.6-fpm-alpine&lt;/a&gt;镜像.这个镜像基于alpine linux的3.4版本制作,特点是体积小,很小,非常小.操作系统本身的大小只有 &lt;strong&gt;不到5MB&lt;/strong&gt; (CentOS/Ubuntu的官方底包至少也要300~500MB),加上php官方构建后整体大小不到90MB,非常方便快速的部署.&lt;/p&gt;

&lt;p&gt;Dockerfile 示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    FROM php:7.1.6-fpm-alpine
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;加点调料&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这一步会对将要构建的环境进行基本的设置,为后续的操作做准备内容包括环境变量的设置,程序依赖的安装,用户/组的创建等等.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ENV 命令 // 设置环境变量&lt;/p&gt;

&lt;p&gt;RUN 命令 // 执行指定的系统命令&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Dockerfile示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ENV NGINX_VERSION 1.12.0
    RUN apk update \
        &amp;amp;&amp;amp; apk add --no-cache --virtual .phpdeps \
        $PHPIZE_DEPS \
        openssl-dev \
        pcre-dev \
        libpng-dev \
        freetype-dev \
        libjpeg-turbo-dev \
        libpng-dev \
        libxml2-dev \
        tzdata
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;来点硬菜&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这一步将开始安装所需要的核心应用,nginx&lt;/p&gt;

&lt;p&gt;编写方式就像你已经ssh登录进这台主机一样,编译安装等等都可以在这部分进行操作.&lt;/p&gt;

&lt;p&gt;Dockerfile示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    RUN GPG_KEYS=B0F4253373F8F6F510D42178520A9993A1C052F8 \
    &amp;amp;&amp;amp; CONFIG=&amp;quot;\
        --prefix=/etc/nginx \
        --sbin-path=/usr/sbin/nginx \
        --modules-path=/usr/lib/nginx/modules \
        --conf-path=/etc/nginx/nginx.conf \
        --error-log-path=/var/log/nginx/error.log \
        --http-log-path=/var/log/nginx/access.log \
        --pid-path=/var/run/nginx.pid \
        --lock-path=/var/run/nginx.lock \
        --http-client-body-temp-path=/var/cache/nginx/client_temp \
        --http-proxy-temp-path=/var/cache/nginx/proxy_temp \
        --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp \
        --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp \
        --http-scgi-temp-path=/var/cache/nginx/scgi_temp \
        --user=nginx \
        --group=nginx \
        --with-http_ssl_module \
        --with-http_realip_module \
        --with-http_addition_module \
        --with-http_sub_module \
        --with-http_dav_module \
        --with-http_flv_module \
        --with-http_mp4_module \
        --with-http_gunzip_module \
        --with-http_gzip_static_module \
        --with-http_random_index_module \
        --with-http_secure_link_module \
        --with-http_stub_status_module \
        --with-http_auth_request_module \
        --with-http_xslt_module=dynamic \
        --with-http_image_filter_module=dynamic \
        --with-http_geoip_module=dynamic \
        --with-threads \
        --with-stream \
        --with-stream_ssl_module \
        --with-stream_ssl_preread_module \
        --with-stream_realip_module \
        --with-stream_geoip_module=dynamic \
        --with-http_slice_module \
        --with-mail \
        --with-mail_ssl_module \
        --with-compat \
        --with-file-aio \
        --with-http_v2_module \
        &amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;餐后甜点&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这一步主要目的是将一些来自外部的应用/系统的设置,植入镜像中&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;COPY 命令 // 从构建机复制指定的文件/目录到容器中&lt;/p&gt;

&lt;p&gt;ADD 命令  // 将指定的文件/目录/URL所对应的文件复制到容器中,和COPY的区别就是支持URL&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Dockerfile示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    COPY supervisord.conf /etc/supervisord.conf

    COPY start.sh /start.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;饭后活动&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这一步是为了以后使用这个构建出来的环境准备对外暴露的接入方式&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;VOLUME 命令 //  创建挂载点,创建的挂载点后,在启动容器时不再需要使用-v参数指定挂在&lt;/p&gt;

&lt;p&gt;EXPOSE 命令 // 用于显示声明容器内应用将会对外暴露的端口,启动容器时需要使用-p参数才会真正映射端口到宿主机&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Dockerfile示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    EXPOSE 9001 80 443 9000
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;收工&amp;amp;结束&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这一步是可选的,用来设置当前制作的镜像启动后的默认动作,在启动容器时可以通过CMD参数来覆盖这个设置的值,不覆盖则默认会执行.&lt;/p&gt;

&lt;p&gt;Dockerfile示例:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ENTRYPOINT 命令 // 设置默认启动行为,只允许有一个,如果写了多个,最后一个会生效,大部分情况下推荐使用ENTRYPOINT,而非CMD命令&lt;/p&gt;

&lt;p&gt;WORKDIR 命令 // 切换操作目录,类似于cd命令,在dockerfile中写cd命令是无效的,需要注意&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    ENTRYPOINT [&amp;quot;sh&amp;quot;,&amp;quot;/start.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;完整Dockerfile奉上&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mustang1988/docker-images/blob/master/php/7.1.6/with-nginx-tools/Dockerfile&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Tips&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;RUN优化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;dockerfile构建的镜像是分层的,每一层都会占据独立的空间,为了节约,请将能合并的RUN命令,尽可能的合并到一条中用 &amp;amp;&amp;amp; 连接.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;清理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;编译安装应用后切记把一些无用的仅编译时需要的组件删除掉,以节约镜像体积,当然还有编译安装时所用到的源码文件,总之就是能删掉的统统删掉,镜像体积能小多少小多少,这和造车轻量化是一样一样一样的.没有人会喜欢一个动不动就几个GB的镜像,那会让你发疯的.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;编写说明文档&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;编写相关的文档,描述镜像的适用范围,暴露的端口,挂载点等等等,为日后的维护提供支持.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;持续构建&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Dockerfile编写完成了,要如何把它构建成镜像呢:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;docker build -t tag名称 Dockerfile所在目录&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;镜像构建的时间是和Dockerfile文件的复杂程度成正比的,还和其他很多因素有关,比如网速,设备性能等等.&lt;/p&gt;

&lt;p&gt;但是每次修改镜像都要手动去执行命令构建是很麻烦的过程,能不能让他监听Dockerfile的改动自动进行呢?答案是可以的.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;docker官方的DockerHub平台就提供了自动构建的功能.下面会简单介绍如何在dockerhub上实现自动构建镜像.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;打开&lt;a href=&#34;https://hub.docker.com/&#34;&gt;DockerHub&lt;/a&gt;页面,&lt;strong&gt;需要翻墙&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;点击登录,推荐使用GitHub帐号登录&lt;/li&gt;

&lt;li&gt;&lt;p&gt;点击右上角的Create-&amp;gt;Create Automated Build&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-13%2000.15.06.png?imageView/2/w/500&#34; alt=&#34;此处应有图&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选择使用GitHub构建&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然后选择你在GitHub创建的构建用的代码库,没有的话可以现去创建一个,公仓私仓都可以(私仓是收费唉,我不是土豪,用不起)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然后填写一些相关的描述文字,点击创建即可,然后就会进入Build Setting页面&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-13%2000.18.06.png?imageView/2/w/500&#34; alt=&#34;此处应有图&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;记得勾选左上角的&amp;rdquo;When active, builds will happen automatically on pushes.&amp;ldquo;,然后选择代码库指定分支,指定目录和对应的镜像Tag,点击保存即可&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;完成上述设置后,当你向指定分支触发push代码的操作后,就会自动读取该分支,该目录下的Dockerfile自动构建镜像了,需要注意构建文件必须使用固定的文件名Dockerfile,大小写敏感.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;由于DockerHub需要翻墙,对吾等天朝民工太不友好,阿里,网易均提供了类似的仓库和构建服务.经过构建速度/镜像拉取速度等方面的比对,发现阿里提供的构建服务完爆网易蜂巢,还是很推荐的.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;打开&lt;a href=&#34;https://dev.aliyun.com/search.html?spm=5176.1972344.0.1.8Ee7SL&#34;&gt;阿里开发者平台&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;点击右上角的管理中心,并登录&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建一个镜像仓库&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-13%2000.46.06.png?imageView/2/w/500&#34; alt=&#34;此处应有图&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置代码源位GitHub,当然也支持其他私有的git仓库&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然后同DockerHub类似的设置分支,目录,标签名等参数(阿里支持非Dockerfile命名的构建文件,这个很贴心,给个赞)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-13%2000.26.25.png?imageView/2/w/500&#34; alt=&#34;此处应有图&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;推送你的Dockerfile到仓库吧&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;记得勾选设置中的&amp;rdquo;代码变更时自动构建镜像&amp;rdquo;和&amp;rdquo;海外机器构建&amp;rdquo;,你会发现下载海外依赖包的速度真的是飞快,比DockerHub还要快一倍以上,赞~赞~赞~&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在仓库基本设置中可以看到自己构建镜像的公开地址,直接复制后面接上&amp;rdquo;:tag名称&amp;rdquo;就可以拉取了.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-13%2000.29.02.png?imageView/2/w/500&#34; alt=&#34;此处应有图&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用自动构建时,记得把你需要ADD或者COPY进镜像的文件和Dockerfile一起提交到版本库.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>PHP 中的 Trait</title>
      <link>https://mustang1988.github.io/post/php-%E4%B8%AD%E7%9A%84trait/</link>
      <pubDate>Mon, 17 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mustang1988.github.io/post/php-%E4%B8%AD%E7%9A%84trait/</guid>
      
        <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Trait是神马&lt;/p&gt;

&lt;p&gt;Trait是PHP5.4.0中加入的语言特性,是一种代码复用机制,为了解决类的单继承导致的一些局限性问题.可以简单理解为一种多重继承的一种替代方案.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Trait和类的继承有何区别&lt;/p&gt;

&lt;p&gt;Trait和类相似, 但仅仅旨在用细粒度和一致的方式来组合功能, Trait无法实例化成具体的对象,如果将传统类的继承理解为纵向的代码复用与拓展,那么trait就提供了横向代码复用的能力.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Trait的具体使用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;什么时候可以使用trait?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;理论上凡是需要或将要使用继承的地方都可以考虑使用trait来实现,其次当有两个完全无关的类(无继承关系,各自有自己独立的父类),但是这两个类有需要编写相同的逻辑实现时,就可以考虑使用trait来拓展类的功能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Trait的使用方式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Trait官方示例:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-17%2015.29.26.png&#34; alt=&#34;官方示例&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Trait和类继承同时使用时的覆盖问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从基类继承的成员会被 trait 插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了 trait 的方法，而 trait 则覆盖了被继承的方法。&lt;/p&gt;

&lt;p&gt;优先级顺序:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;子类override的父类方法 &amp;gt; trait方法 &amp;gt; 子类继承自父类的方法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当前类的成员方法 &amp;gt; trait方法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;多个Trait同时使用&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;和implement接口类似,在use引入trait时,允许同时引入多个trait,并使用逗号隔开.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;trait冲突&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当一个类引入了多个trait,且这些trait中都定义了相同名称的方法,此时就会出现trait冲突,如果逻辑中没有编写对应的处理,则会抛出异常中断执行.
当发生trait冲突时,需要使用 insteadof 操作符来明确指定使用冲突方法中的哪一个。以上方式仅允许排除掉其它方法，as 操作符可以将其中一个冲突的方法以另一个名称来引入。&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-17%2015.32.12.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-17%2015.32.20.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;trait的组合&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;trait支持组合使用,也就是在一个trait中可以引入另一个或多个 trait来组合成一个新的trait,通过把逻辑实现的最小单元化,理论上可以用不同的trait排列组合,整合出无穷多的新trait,从而取代传统类的继承都不在话下.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;trait中的抽象成员&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;trait中也允许定义抽象成员方法,当有其他类引用该trait时必须对其中的抽象方法编写实现,类似于抽象类和接口的使用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;trait中可以定义静态方法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;trait中的属性定义&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;trait中可以定义属性,如果引入trait的类和trait中定义的属性存在冲突,则会抛出异常,但是,如果类中定义的属性和trait中定义的属性兼容(相同的访问修饰符和初始值)则类中的属性会覆盖trait中的,否则抛出异常.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;总结&lt;/p&gt;

&lt;p&gt;Trait特性可以说从根本上解决了单继承语言代码横向复用的大问题,利用trait的自由任意组合的机制,理论上都可以吧类的继承完全替代掉.但是trait使用时需要注意的问题点也比较多,尤其是成员方法的命名冲突,因为PHP是没有方法重载的,所以这个问题会变得尤其突出,所以在我们日常使用的时候需要特别小心.&lt;/p&gt;

&lt;p&gt;现如今主流的PHP框架中都或多或少的引入了trait特性来实现一些意想不到的功能,比如yii的ORM组件就大量的使用了trait来组合通用的数据库查询实现:&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>Git Commit 规范指南</title>
      <link>https://mustang1988.github.io/post/git-commit-%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/</link>
      <pubDate>Fri, 14 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mustang1988.github.io/post/git-commit-%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/</guid>
      
        <description>

&lt;h2 id=&#34;1-commit-message-有啥用&#34;&gt;1. Commit message 有啥用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;提供更多的历史信息，方便快速浏览&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以过滤某些commit(比如文档改动)，便于快速查找信息&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以直接从commit生成Change log,Change Log 是发布新版本时，用来说明与上一个版本差异的文档.例如:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clowuddn.com/6632199163166779416.png?imageView/2/w/350&#34; alt=&#34;example&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;其他优点:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可读性好，清晰，不必深入看代码即可了解当前commit的作用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为 Code Reviewing 做准备&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;方便跟踪工程历史&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;让其他的开发者在运行 git blame 的时候想跪谢&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提高项目的整体质量，提高个人工程素质&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-正确的-commit-message-的使用姿势&#34;&gt;2. 正确的 Commit message 的使用姿势&lt;/h2&gt;

&lt;p&gt;每次提交，Commit message 都包括三个部分：Header，Body 和 Footer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;type&amp;gt;(&amp;lt;scope&amp;gt;): &amp;lt;subject&amp;gt;
    &amp;lt;空行&amp;gt;
    &amp;lt;body&amp;gt;
    &amp;lt;空行&amp;gt;
    &amp;lt;footer&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-header&#34;&gt;1. Header&lt;/h3&gt;

&lt;p&gt;Header部分只有一行，包括三个字段：type(必需)、scope(可选)和subject(必需)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;type&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用于说明 commit 的类别，只允许使用下面7个标识&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;标识&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;feat&lt;/td&gt;
&lt;td&gt;新增功能(feature)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;fix&lt;/td&gt;
&lt;td&gt;修复bug&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;docs&lt;/td&gt;
&lt;td&gt;文档更新&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;style&lt;/td&gt;
&lt;td&gt;更新代码格式,不影响代码的原始逻辑和执行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;refactor&lt;/td&gt;
&lt;td&gt;重构(即不是新增功能，也不是修改bug的代码)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;test&lt;/td&gt;
&lt;td&gt;新增单元测试用例&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;chore&lt;/td&gt;
&lt;td&gt;构建过程或辅助工具的变动&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;perf&lt;/td&gt;
&lt;td&gt;提升优化性能&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;deps&lt;/td&gt;
&lt;td&gt;升级依赖&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;scope&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同
如果你的修改影响了不止一个scope，你可以使用*代替&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;subject&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;subject是 commit 目的的简短描述需要注意以下事项:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;注意点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不超过50个字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;以动词开头，使用第一人称现在时，比如change，而不是changed或changes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;第一个字母小写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;结尾不加句号（.）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-body&#34;&gt;2. Body&lt;/h3&gt;

&lt;p&gt;Body 部分是对本次 commit 的详细描述，可以分成多行,Body编写注意点:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;注意点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;每行不超过72个字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;段落之间用空行隔开&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;分段表述时,使用悬挂缩进&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用第一人称现在时，比如使用change而不是changed或changes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;应该说明代码变动的动机，以及与以前行为的对比&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;3-footer&#34;&gt;3. Footer&lt;/h3&gt;

&lt;p&gt;通常情况下的commit是不需要编写Footer部分的说明的,仅在以下情况发生时编写&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不兼容变动&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;关闭 Issue&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Revert&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header.Body部分的格式是固定的，必须写成This reverts commit &lt;hash&gt;.，其中的hash是被撤销 commit 的 SHA 标识符.如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面&lt;/p&gt;

&lt;h3 id=&#34;4-示例&#34;&gt;4.示例&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;初始化创建一个新的Git版本库&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;给初始化提交添加版本标签(0.0.1)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/init.png&#34; alt=&#34;init&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;提交一个新功能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git log 0.0.1 HEAD --grep feat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/feat.png&#34; alt=&#34;feat&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提交一个bug修正&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git log 0.0.1 HEAD --grep fix
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/fix.png&#34; alt=&#34;fix&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提交一次文档更新&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git log 0.0.1 HEAD --grep docs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/docs.png&#34; alt=&#34;docs&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提交一次代码格式修改&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  git log 0.0.1 HEAD --grep style
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/style.png&#34; alt=&#34;style&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;提交一次代码优化重构&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  git log 0.0.1 HEAD --grep refactor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/refactor.png&#34; alt=&#34;refactor&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;提交一个单元测试&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  git log 0.0.1 HEAD --grep test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/test.png&#34; alt=&#34;test&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;查看所有git提交记录
&lt;code&gt;
git log 0.0.1 HEAD --pretty=format:%s
&lt;/code&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-19%2015.54.18.png&#34; alt=&#34;log&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;a href=&#34;https://github.com/jonas/tig&#34;&gt;tig&lt;/a&gt;查看到的提交记录:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-19%2015.59.36.png&#34; alt=&#34;tig&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-生成changelog&#34;&gt;5.生成changelog&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装工具&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g conventional-changelog-cli
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置conventional-changelog&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  cd  项目目录
  npm init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改 package.json,添加:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  &amp;quot;scripts&amp;quot;: {
      &amp;quot;changelog&amp;quot;: &amp;quot;conventional-changelog -p angular -i CHANGELOG.md -s -r 0&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;执行命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm run changelog
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看版本库目录下生成的CHANGELOG.md文件,如下图所示:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://oojbdbtdp.bkt.clouddn.com/changelog.png?imageView/2/w/350&#34; alt=&#34;changelog&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;工具默认只会将feat和fix这两个type的commit信息抓取出来并生成到CHANGELOG.md文件中.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-sourcetree-配置默认commit-message-模板&#34;&gt;6.SourceTree 配置默认commit message 模板&lt;/h3&gt;

&lt;p&gt;SourceTree提供了自定义的提交模板配置功能.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在SourceTree中点击仓库菜单-&amp;gt;仓库设置-&amp;gt;提交模板
填入以下内容:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type(scope): subject  

body  

bodydetail  

foot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存设置,之后每次commit代码时,这个模板就会自动的填充到commit message中,然后我们只需要替换修改必要的部分就好了.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-参考文献&#34;&gt;3.参考文献:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.uyo6cb12dt6w&#34;&gt;AngularJS Git Commit Message Conventions&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000009048911&#34;&gt;git commit 规范指南&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html&#34;&gt;Commit message 和 Change log 编写指南&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/angular/angular.js/blob/master/CONTRIBUTING.md#toc10&#34;&gt;Contributing to AngularJS&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
  </channel>
</rss>